"""Module containing the reading and conversion logic"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_convert.ipynb.

# %% auto 0
__all__ = ['read_sl', 'extract_height', 'clean_gdf', 'slx2gdf', 'export_gdf', 'process_sonar_file']

# %% ../nbs/00_convert.ipynb 3
import geopandas as gpd
import pandas as pd
import re
from pathlib import Path
from sonarlight import Sonar

# %% ../nbs/00_convert.ipynb 11
def read_sl(
    filepath: Path # The absolute location of the file to convert
    )->Sonar:
    return Sonar(str(filepath))

# %% ../nbs/00_convert.ipynb 27
def extract_height(
    sl_filepath: Path, # The absolute location of the file to convert
    re_ptrn: str=r"[+-]?\d+(?=cmnap)"
    )->int: # The height of the measurement station in cm above NAP
    "Extract height from the filename in cmNAP"
    if 'cmnap' not in str(sl_filepath).lower():
        raise ValueError("The filename must contain the height of the Sonar boot at time of measurement in 'cmNAP' at the end of the filename (e.g. 'example_description_+1050cmNAP.sl2')")
    return int(re.search(re_ptrn, str(sl_filepath), flags=re.IGNORECASE)[0])

# %% ../nbs/00_convert.ipynb 58
def clean_gdf(
    gdf: gpd.GeoDataFrame, # GeoDataFrame from sl2gdf
    msrmnt_height: int, # Height of measurement instrument in cm above NAP
    ) -> gpd.GeoDataFrame: # Cleaned GeoDataFrame with bottom_height column
    "Filter primary survey data, remove duplicates, and calculate bottom height in mNAP"
    df_cln = (gdf[gdf["survey"]=="primary"]
            .groupby(['longitude', 'latitude'], as_index=False).agg(
                mean_depth=pd.NamedAgg(column="water_depth", aggfunc="mean"),
                min_depth=pd.NamedAgg(column="water_depth", aggfunc="min"),
                max_depth=pd.NamedAgg(column="water_depth", aggfunc="max"),
                geometry=pd.NamedAgg(column="geometry", aggfunc="first"),
                datetime=pd.NamedAgg(column="datetime", aggfunc="mean")
            )
            .assign(bottom_height=lambda x: msrmnt_height / 100 - x['mean_depth']))
    return gpd.GeoDataFrame(df_cln, geometry='geometry', crs=gdf.crs)

# %% ../nbs/00_convert.ipynb 64
def slx2gdf(
    sl_filepath: Path, # The absolute location of the file to convert
    to_crs: str = "epsg:28992", # epsg code of crs to transform the coÃ¶rdinates to
    survey_fltr: str = "primary", # Filter measurement facts on survey value
    )->gpd:
    "Convert a sl2 or sl3 file to a GeoDataFrame with the given crs."
    s = Sonar(str(sl_filepath))
    df = s.df
    required_cols = ['longitude', 'latitude', 'water_depth', 'survey']
    if not all(col in df.columns for col in required_cols):
        raise KeyError(f"Missing one or more of the required columns in the converted sl2 or sl3 file.\nRequired columns are: 'longitude', 'latitude', 'water_depth' and 'survey'")
    gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df.longitude, df.latitude))
    gdf = gdf.set_crs(epsg=4326)
    return gdf.to_crs(to_crs)

# %% ../nbs/00_convert.ipynb 69
def export_gdf(
    gdf: gpd.GeoDataFrame, # GeoDataFrame to be saved
    fn: str, # Filename of the GeoDataFrame without extension
    folder_out: Path, # Absolute path to folder where files can be saved
    esri_shp: bool=True, # Save GeoDataFrame to Esri shapefile?
    csv: bool=True, # Save GeoDataFrame to comma seperated file?
    geopckg: bool=True, # Save GeoDataFrame to geopackage?
    ) -> None:
    "Deze functie doet iets"
    if esri_shp: gdf.to_file(folder_out / f"{fn}.shp")
    if geopckg: gdf.to_file(folder_out / f"{fn}.gpkg", driver="GPKG")
    if csv:
        gdf['x'] = gdf.geometry.x
        gdf['y'] = gdf.geometry.y
        df = gdf.drop(columns=['geometry'])
        df.to_csv(folder_out / f"{fn}.csv", index=False)
    return

# %% ../nbs/00_convert.ipynb 72
def process_sonar_file(
    sl_filepath: Path, # Path to sl2 or sl3 file
    folder_out: Path, # Output folder for exported files
    to_crs: str = "epsg:28992" # Target CRS
    ) -> None:
    "Process sonar file: extract height, convert to GeoDataFrame, clean, and export"
    msrmnt_height = extract_height(str(sl_filepath.stem))
    gdf = slx2gdf(sl_filepath, to_crs=to_crs)
    gdf_clean = clean_gdf(gdf, msrmnt_height)
    export_gdf(gdf_clean, sl_filepath.stem, folder_out)
